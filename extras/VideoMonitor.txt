
#include <VideoMonitor.h>
#include <Log.h>

#include <EGL/egl.h>
#include <GLES2/gl2.h>

#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <err.h>
#include <sys/mman.h>
#include <string.h>

#include <iostream>
#include <fstream>
#include <sstream>

using namespace std;

#define BOOL_ASSERT(x...)	\
{							\
	if (x)					\
	{						\
		DBG("Error code: ", glGetError());	\
		return false;		\
	}						\
}


VideoMonitor::VideoMonitor()
{

}

VideoMonitor::~VideoMonitor()
{
}

int VideoMonitor::Run()
{
//	Init();
//	while(run)
//	{
//		Update();
//		Render();
//	}
//	Cleanup();
	return 0;
}

void VideoMonitor::Update()
{
//	receiver.Discover();
}

void VideoMonitor::Render()
{


}
void VideoMonitor::Cleanup()
{

}

bool VideoMonitor::Init(GBM_Instance &gbm, const EGL_Instance &egl)
{
	(void) egl;
	int ret;

	aspect = (GLfloat)(gbm.h() ) / (GLfloat)(gbm.w());
//	gl.gbm = gbm;

	ret = create_program(scene_vs, scene_fs);
	if (ret < 0)
		return NULL;

	program = ret;

	glBindAttribLocation(program, 0, "in_position");
	glBindAttribLocation(program, 1, "in_normal");
	glBindAttribLocation(program, 2, "in_color");

	ret = link_program(program);
	if (ret)
		return NULL;

	glUseProgram(program);

	modelviewmatrix = glGetUniformLocation(program, "modelviewMatrix");
	modelviewprojectionmatrix = glGetUniformLocation(program, "modelviewprojectionMatrix");
	normalmatrix = glGetUniformLocation(program, "normalMatrix");
	texture   = glGetUniformLocation(program, "uTex");

	glViewport(0, 0, gbm.w(), gbm.h());
	glEnable(GL_CULL_FACE);

	positionsoffset = 0;
	texcoordsoffset = sizeof(vVertices);
	normalsoffset = sizeof(vVertices) + sizeof(vTexCoords);

	glGenBuffers(1, &vbo);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vVertices) + sizeof(vTexCoords) + sizeof(vNormals), 0, GL_STATIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, positionsoffset, sizeof(vVertices), &vVertices[0]);
	glBufferSubData(GL_ARRAY_BUFFER, texcoordsoffset, sizeof(vTexCoords), &vTexCoords[0]);
	glBufferSubData(GL_ARRAY_BUFFER, normalsoffset,   sizeof(vNormals), &vNormals[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid *)(intptr_t)positionsoffset);
	glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid *)(intptr_t)normalsoffset);
	glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 0, (const GLvoid *)(intptr_t)texcoordsoffset);

	if ( ! init_shadertoy(shader_file)) {
		printf("failed to initialize\n");
		return false;
	}

	return true;
}

bool VideoMonitor::init_shadertoy(const char *file)
{
	int ret = load_shader(file);
	stoy_program = ret;

	glBindAttribLocation(program, 0, "position");

	ret = link_program(stoy_program);

	glUseProgram(stoy_program);
	stoy_time_loc = glGetUniformLocation(stoy_program, "iTime");

	/* we can set iResolution a single time, it doesn't change: */
	GLint resolution_location = glGetUniformLocation(stoy_program, "iResolution");
	glUniform3f(resolution_location, texw, texh, 0);

	glGenFramebuffers(1, &stoy_fbo);
	glGenTextures(1, &stoy_fbotex);
	glBindFramebuffer(GL_FRAMEBUFFER, stoy_fbo);

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, stoy_fbotex);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, texw, texh, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D,
		stoy_fbotex, 0);

	const GLfloat vertices[] = {
		-1.0f, -1.0f, 0.0f,
		 1.0f, -1.0f, 0.0f,
		-1.0f,  1.0f, 0.0f,
		 1.0f,  1.0f, 0.0f,
	};
	glGenBuffers(1, &stoy_vbo);
	glBindBuffer(GL_ARRAY_BUFFER, stoy_vbo);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), 0, GL_STATIC_DRAW);
	glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), &vertices[0]);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (const GLvoid *)(intptr_t)0);

	return 0;
}


int VideoMonitor::create_program(const char *vs_src, const char *fs_src)
{
	GLuint vertex_shader, fragment_shader, program;
	GLint ret;

	vertex_shader = glCreateShader(GL_VERTEX_SHADER);

	glShaderSource(vertex_shader, 1, &vs_src, NULL);
	glCompileShader(vertex_shader);

	glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &ret);
	if (!ret) {
		char *log;

		printf("vertex shader compilation failed!:\n");
		glGetShaderiv(vertex_shader, GL_INFO_LOG_LENGTH, &ret);
		if (ret > 1) {
			log = (char *)malloc(ret);
			glGetShaderInfoLog(vertex_shader, ret, NULL, log);
			printf("%s", log);
			free(log);
		}

		return -1;
	}

	fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);

	glShaderSource(fragment_shader, 1, &fs_src, NULL);
	glCompileShader(fragment_shader);

	glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &ret);
	if (!ret) {
		char *log;

		printf("fragment shader compilation failed!:\n");
		glGetShaderiv(fragment_shader, GL_INFO_LOG_LENGTH, &ret);

		if (ret > 1) {
			log = (char *)malloc(ret);
			glGetShaderInfoLog(fragment_shader, ret, NULL, log);
			printf("%s", log);
			free(log);
		}

		return -1;
	}

	program = glCreateProgram();

	glAttachShader(program, vertex_shader);
	glAttachShader(program, fragment_shader);

	return program;
}

int VideoMonitor::link_program(unsigned program)
{
	GLint ret;

	glLinkProgram(program);

	glGetProgramiv(program, GL_LINK_STATUS, &ret);
	if (!ret) {
		char *log;

		printf("program linking failed!:\n");
		glGetProgramiv(program, GL_INFO_LOG_LENGTH, &ret);

		if (ret > 1) {
			log = (char *)malloc(ret);
			glGetProgramInfoLog(program, ret, NULL, log);
			printf("%s", log);
			free(log);
		}

		return -1;
	}

	return 0;
}


int VideoMonitor::load_shader(const char *file)
{
	ifstream input;
	stringstream text;

	input.open(file);
	text << fullscreen_fs_head << file << fullscreen_fs_tail;
	input.close();

	return create_program(fullscreen_vs, (const char *)text.str().c_str());
}

/*
int VideoMonitor::load_shader(const char *file)
{
	struct stat statbuf;
	char *frag;
	int fd, ret;


	fd = open(file, 0);
	if (fd < 0) {
		err(fd, "could not open '%s'", file);
	}

	ret = fstat(fd, &statbuf);
	if (ret < 0) {
		err(ret, "could not stat '%s'", file);
	}

	const char *text =
		(char *) mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

	asprintf(&frag, fullscreen_fs, text);

	return create_program(fullscreen_vs, frag);
}
*/

const GLfloat VideoMonitor::vVertices[12] =
{
	-1.0f, -1.0f, 0.0f,
	+1.0f, -1.0f, 0.0f,
	-1.0f, +1.0f, 0.0f,
	+1.0f, +1.0f, 0.0f
};

const GLfloat VideoMonitor::vTexCoords[8] =
{
	1.0f, 1.0f,
	0.0f, 1.0f,
	1.0f, 0.0f,
	0.0f, 0.0f
};

const GLfloat VideoMonitor::vNormals[12] =
{
	+0.0f, +0.0f, +1.0f, // forward
	+0.0f, +0.0f, +1.0f, // forward
	+0.0f, +0.0f, +1.0f, // forward
	+0.0f, +0.0f, +1.0f, // forward
};

const char VideoMonitor::shader_file[] = "extras/convert.glsl";

const char VideoMonitor::scene_vs[] =
	"uniform mat4 modelviewMatrix;      \n"
	"uniform mat4 modelviewprojectionMatrix;\n"
	"uniform mat3 normalMatrix;         \n"
	"                                   \n"
	"attribute vec4 in_position;        \n"
	"attribute vec3 in_normal;          \n"
	"attribute vec2 in_TexCoord;        \n"
	"                                   \n"
	"vec4 lightSource = vec4(2.0, 2.0, 20.0, 0.0);\n"
	"                                   \n"
	"varying vec4 vVaryingColor;        \n"
	"varying vec2 vTexCoord;            \n"
	"                                   \n"
	"void main()                        \n"
	"{                                  \n"
	"    gl_Position = modelviewprojectionMatrix * in_position;\n"
	"    vec3 vEyeNormal = normalMatrix * in_normal;\n"
	"    vec4 vPosition4 = modelviewMatrix * in_position;\n"
	"    vec3 vPosition3 = vPosition4.xyz / vPosition4.w;\n"
	"    vec3 vLightDir = normalize(lightSource.xyz - vPosition3);\n"
	"    float diff = max(0.0, dot(vEyeNormal, vLightDir));\n"
	"    vVaryingColor = vec4(diff * vec3(1.0, 1.0, 1.0), 1.0);\n"
	"    vTexCoord = in_TexCoord; \n"
	"}                            \n";

const char VideoMonitor::scene_fs[] =
	"precision mediump float;           \n"
	"                                   \n"
	"uniform sampler2D uTex;            \n"
	"                                   \n"
	"varying vec4 vVaryingColor;        \n"
	"varying vec2 vTexCoord;            \n"
	"                                   \n"
	"void main()                        \n"
	"{                                  \n"
	"    gl_FragColor = vVaryingColor * texture2D(uTex, vTexCoord);\n"
	"}                                  \n";

const char VideoMonitor::transcode_vs[] =
	"attribute vec3 position;           \n"
	"void main()                        \n"
	"{                                  \n"
	"    gl_Position = vec4(position, 1.0);\n"
	"}                                  \n";

//	const char transcode_fs_head[] =
const char VideoMonitor::transcode_fs_impl[] =
	"precision mediump float;                                                             \n"
	"uniform vec3      iResolution;           // viewport resolution (in pixels)          \n"
	"uniform float     iGlobalTime;           // shader playback time (in seconds)        \n"
	"uniform vec4      iMouse;                // mouse pixel coords                       \n"
	"uniform vec4      iDate;                 // (year, month, day, time in seconds)      \n"
	"uniform float     iSampleRate;           // sound sample rate (i.e., 44100)          \n"
	"uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)           \n"
	"uniform float     iChannelTime[4];       // channel playback time (in sec)           \n"
	"uniform float     iTime;                                                             \n"
//		"                                                                                     \n";
//	const char transcode_fs_tail[] =
	"                                                                                     \n"
	"void main()                                                                          \n"
	"{                                                                                    \n"
	"    mainImage(gl_FragColor, gl_FragCoord.xy);                                        \n"
	"}                                                                                    \n";


const char VideoMonitor::fullscreen_vs[] =
		"attribute vec3 position;                \n"
		"void main()                             \n"
		"{                                       \n"
		"    gl_Position = vec4(position.x, position.y*0.8, position.z, 1.0);  \n"
		"}                                       \n";

const char VideoMonitor::fullscreen_fs_head[] =
		"precision mediump float;                                                             \n"
		"uniform vec3      iResolution;           // viewport resolution (in pixels)          \n"
		"uniform float     iTime;                 // shader playback time (in seconds)        \n"
		"uniform int       iFrame;                // current frame number                     \n"
		"uniform float pPixels; \n"
		"uniform float pPairs;  \n"
		"uniform sampler2D pVideo; \n"
		"                                                                                     \n"
	;//	"%s                                                                                   \n"
const char VideoMonitor::fullscreen_fs_tail[] =
		"                                                                                     \n"
		"void main()                                                                          \n"
		"{                                                                                    \n"
		"    mainImage(gl_FragColor, gl_FragCoord.xy);                                        \n"
		"}                                                                                    \n";

